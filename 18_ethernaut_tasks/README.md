# Решение задач https://ethernaut.openzeppelin.com

## 1. Fallback
Функция receive() позволяет завладеть контрактом. Для этого один раз вызовем contribute(), затем просто отправим транзакцию с некоторой суммой.

## 2. CoinFlip
Алгоритм используемый для расчета случайного значения завязан на block.number. Мы можем написать свой контракт в котором расчитаем это значение и следом вызовем метод flip() контракта. В метод передадим уже расчитанное значение. Расчет становится возможным благодаря тому, что мы совершим операцию расчета и вызоыва метода flip() внутри одной транзакции - внутри одного блока.

Важное: При вызове метода контракта - вложенные вызовы к другим контрактам будут совершены внутри одной транзакции

Решение:
- изменить алгоритм генерации случайного числа
- использовать паттерн ?commitreview?

## 4. Telephone
Контракт меняет владельца если адрес msg.sender != адресу создателя транзакции tx.origin. Для этого нужен "middle address" или прокси адресс. Данное условие выполнимо если вызвать метод changeOwner() через call() из другого контракта (middle address).

## 5. Token
overflow и underflow до версии 0.8 solidity
поведение uint8 -> 0 - 1 = 254
В 0.8 solidity -> порождается exception. Сейча выше описанной поведение возможно только если использовать:
```
unchecked {
    //uint8 -> 0 - 1 = 254
    //uint8 -> 255 + 1 = 0
}
```

## 6. Delegation
Контракт Delegation уязвим, т.к. внутри себя использует delegatecall().
Нас остается только вызвать не существующий метод у Delegation, чтобы попасть в fallback(). При этом в качестве данных укажем метод "pwn()" из Delegate.
За счет delegatecall() метод pwn() будет вызван в контексте Delegation. В результате owner перепишется на msg.sender.
```
// Hack.attack() --> Delegation.fallback() 
// Delegation.fallback.delegatecall() --> Delegate.pwn()
```

## 7. Force
Пустой контракт. Без функции receive() он не может принимать средства. Но отсутствие этого метода можно обойти.
2 случая:
- награда майнеру
- прием средств от другого контракта, в котором был вызван selfdestruct()
Наличие реализованного метода receive() с вызовом revert() не решает проблему. При зачислении средств через selfdestruct() не вызывается метод receive().

## 8. Vault
Задача на чтение private данных из blockchain.
```
ethers.provider.getStorageAt(адрес контракта, номер слота для чтения данных)
```

Пример работы:
```
# npx hardhat deploy --network localhost
# or
npx hardhat run scripts/deploy.js --network localhost
npx hardhat console --network localhost

# адрес контракта, номер слота для чтения данных
# 0 - bool public locked
> await ethers.provider.getStorageAt("0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512", 0)
'0x0000000000000000000000000000000000000000000000000000000000000001'

# 1 - bytes32 private password
> await ethers.provider.getStorageAt("0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512", 1)
'0x7365637265740000000000000000000000000000000000000000000000000000'

# Сравним значение с байт строкой "secret"
> ethers.utils.formatBytes32String("secret")
'0x7365637265740000000000000000000000000000000000000000000000000000'
# идентичны
```

## 9 King
Нарушить логику контракта можно отправкой ставки через контракт, в котором отсутствует метод receive().

## 12 Privacy
Задача похожа на 9. Отличие в том, что данные упакованы в слоты и нужно правильно выбрать нужные данные.
3-5 Искомые слоты
```
> await ethers.provider.getStorageAt("0x5FbDB2315678afecb367f032d93F642f64180aa3", 0)
'0x0000000000000000000000000000000000000000000000000000000000000001'
> await ethers.provider.getStorageAt("0x5FbDB2315678afecb367f032d93F642f64180aa3", 1)
'0x00000000000000000000000000000000000000000000000000000000629e4ee0'
> await ethers.provider.getStorageAt("0x5FbDB2315678afecb367f032d93F642f64180aa3", 2)
'0x000000000000000000000000000000000000000000000000000000004ee0ff0a'
> await ethers.provider.getStorageAt("0x5FbDB2315678afecb367f032d93F642f64180aa3", 3)
'0x7365637265743100000000000000000000000000000000000000000000000000'
> await ethers.provider.getStorageAt("0x5FbDB2315678afecb367f032d93F642f64180aa3", 4)
'0x7365637265743200000000000000000000000000000000000000000000000000'
> await ethers.provider.getStorageAt("0x5FbDB2315678afecb367f032d93F642f64180aa3", 5)
'0x7365637265743300000000000000000000000000000000000000000000000000'
> ethers.utils.formatBytes32String("secret1")
'0x7365637265743100000000000000000000000000000000000000000000000000'
> ethers.utils.formatBytes32String("secret2")
'0x7365637265743200000000000000000000000000000000000000000000000000'
> ethers.utils.formatBytes32String("secret3")
'0x7365637265743300000000000000000000000000000000000000000000000000'
```

## 14 GatekeeperTwo
Первые ворота можно пройти вызвав метод через call() прокси контракта.
Вторые ворота требуют, чтобы у отправителя транзакции поле code было пустым. Для этого в прокси контракте нужно перенести код в конструктор.
В третьих воротах выполняется функция XOR и сравнивается с результатом. Воспользуемся свойством:
```
a XOR b = c
a XOR с = b
```
и расчитаем key.